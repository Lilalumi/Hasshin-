%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 646c6b769fd7da5439215dc13e984256, type: 3}
  m_Name: Text Data 3
  m_EditorClassIdentifier: 
  content: "using System.Collections;\r\nusing System.Collections.Generic;\r\nusing
    UnityEngine;\r\nusing TMPro;\r\n#if UNITY_EDITOR\r\nusing UnityEditor;\r\n#endif\r\n\r\npublic
    class DynamicCodeDisplay : MonoBehaviour\r\n{\r\n    [Header(\"UI Settings\")]\r\n   
    [SerializeField] private TextMeshProUGUI textMeshPro; // Referencia al TextMeshPro
    - Text (UI)\r\n    [SerializeField] private float typingSpeed = 0.05f; // Velocidad
    de escritura (segundos entre caracteres)\r\n    [SerializeField] private float
    delayBetweenTexts = 2f; // Tiempo de espera entre textos\r\n    [SerializeField]
    private int maxLines = 10; // M\xE1ximo de l\xEDneas visibles en el texto\r\n\r\n   
    [Header(\"Text Data Settings\")]\r\n    [SerializeField] private TextData[] textDataArray;
    // Array de ScriptableObjects con los textos\r\n#if UNITY_EDITOR\r\n    [SerializeField]
    private DefaultAsset folder; // Carpeta seleccionable desde el Inspector\r\n#endif\r\n\r\n   
    private Queue<string> visibleLines = new Queue<string>(); // Cola para manejar
    las l\xEDneas visibles\r\n    private System.Random random = new System.Random();
    // Generador de n\xFAmeros aleatorios\r\n\r\n    void Start()\r\n    {\r\n       
    if (textDataArray == null || textDataArray.Length == 0)\r\n        {\r\n           
    Debug.LogError(\"No se asignaron TextData en el Inspector.\");\r\n           
    return;\r\n        }\r\n\r\n        // Inicia la reproducci\xF3n din\xE1mica
    de los textos\r\n        StartCoroutine(DisplayTexts());\r\n    }\r\n\r\n#if
    UNITY_EDITOR\r\n    private void OnValidate()\r\n    {\r\n        if (folder
    != null)\r\n        {\r\n            LoadTextDataFromFolder();\r\n        }\r\n   
    }\r\n\r\n    private void LoadTextDataFromFolder()\r\n    {\r\n        string
    folderPath = AssetDatabase.GetAssetPath(folder);\r\n\r\n        if (string.IsNullOrEmpty(folderPath))\r\n       
    {\r\n            Debug.LogWarning(\"La carpeta seleccionada no es v\xE1lida.\");\r\n           
    return;\r\n        }\r\n\r\n        // Busca todos los objetos TextData dentro
    de la carpeta\r\n        string[] guids = AssetDatabase.FindAssets(\"t:TextData\",
    new[] { folderPath });\r\n        List<TextData> loadedTextData = new List<TextData>();\r\n\r\n       
    foreach (string guid in guids)\r\n        {\r\n            string assetPath =
    AssetDatabase.GUIDToAssetPath(guid);\r\n            TextData textData = AssetDatabase.LoadAssetAtPath<TextData>(assetPath);\r\n           
    if (textData != null)\r\n            {\r\n                loadedTextData.Add(textData);\r\n           
    }\r\n        }\r\n\r\n        textDataArray = loadedTextData.ToArray(); // Actualiza
    el array con los resultados\r\n    }\r\n#endif\r\n\r\n    private IEnumerator
    DisplayTexts()\r\n    {\r\n        while (true)\r\n        {\r\n            //
    Selecciona un TextData aleatorio\r\n            int randomIndex = random.Next(0,
    textDataArray.Length);\r\n            string[] textLines = textDataArray[randomIndex].content.Split('\\n');
    // Divide el texto en l\xEDneas\r\n\r\n            // Limpia las l\xEDneas visibles
    antes de mostrar el siguiente texto\r\n            ClearVisibleLines();\r\n\r\n           
    // Escribe l\xEDnea por l\xEDnea\r\n            foreach (string line in textLines)\r\n           
    {\r\n                yield return StartCoroutine(TypeLine(line)); // Escribe
    una l\xEDnea car\xE1cter por car\xE1cter\r\n            }\r\n\r\n           
    // Espera antes de pasar al siguiente texto\r\n            yield return new WaitForSeconds(delayBetweenTexts);\r\n       
    }\r\n    }\r\n\r\n    private IEnumerator TypeLine(string line)\r\n    {\r\n       
    string currentLine = \"\"; // L\xEDnea actual que se est\xE1 escribiendo car\xE1cter
    por car\xE1cter\r\n\r\n        foreach (char character in line)\r\n        {\r\n           
    currentLine += character; // Agrega el car\xE1cter actual\r\n            UpdateVisibleLines(currentLine);
    // Actualiza las l\xEDneas visibles\r\n            yield return new WaitForSeconds(typingSpeed);
    // Espera seg\xFAn la velocidad de escritura\r\n        }\r\n\r\n        // Una
    vez completada la l\xEDnea, agr\xE9gala definitivamente\r\n        AddLineToVisibleLines(currentLine);\r\n   
    }\r\n\r\n    private void AddLineToVisibleLines(string line)\r\n    {\r\n       
    // Agrega la l\xEDnea completa a la cola de l\xEDneas visibles\r\n        visibleLines.Enqueue(line);\r\n\r\n       
    // Limita el n\xFAmero de l\xEDneas visibles\r\n        if (visibleLines.Count
    > maxLines)\r\n        {\r\n            visibleLines.Dequeue(); // Elimina la
    l\xEDnea m\xE1s antigua\r\n        }\r\n\r\n        UpdateText(); // Actualiza
    el texto completo\r\n    }\r\n\r\n    private void UpdateVisibleLines(string
    inProgressLine)\r\n    {\r\n        // Crea una lista temporal con las l\xEDneas
    visibles m\xE1s la l\xEDnea en progreso\r\n        var tempLines = new List<string>(visibleLines);\r\n       
    tempLines.Add(inProgressLine);\r\n\r\n        // Si excede el m\xE1ximo de l\xEDneas
    visibles, elimina las m\xE1s antiguas\r\n        while (tempLines.Count > maxLines)\r\n       
    {\r\n            tempLines.RemoveAt(0);\r\n        }\r\n\r\n        // Actualiza
    el texto temporalmente\r\n        textMeshPro.text = string.Join(\"\\n\", tempLines);\r\n   
    }\r\n\r\n    private void ClearVisibleLines()\r\n    {\r\n        visibleLines.Clear();
    // Limpia la cola de l\xEDneas visibles\r\n        textMeshPro.text = \"\"; //
    Limpia el texto en pantalla\r\n    }\r\n\r\n    private void UpdateText()\r\n   
    {\r\n        // Actualiza el texto combinando las l\xEDneas visibles en la cola\r\n       
    textMeshPro.text = string.Join(\"\\n\", visibleLines);\r\n    }\r\n}\r\n"
